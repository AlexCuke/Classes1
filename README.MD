Задача 1. Склад товаров (композиция + классы)
Сделайте систему классов для простого склада.​

'''Требования:

Класс Product: атрибуты name, price, quantity.​

Класс Warehouse: хранит список продуктов self.products.​

Методы Warehouse:

add_product(product): добавить товар (если товар с таким именем уже есть — увеличить его quantity).​

remove_product(name, qty): уменьшить количество, если не хватает — выбросить ValueError.​

total_value(): вернуть общую стоимость всех товаров на складе.​

В основной части: создать склад, добавить несколько товаров, часть «продать», вывести итоговую стоимость.​
'''
Задача 2. Библиотека книг (композиция + поиск)
Нужно смоделировать библиотеку.​

Требования:

Класс Book: title, author, year, is_available (по умолчанию True).​

Класс Library: хранит список книг.​

Методы Library:

add_book(book) — добавить книгу.​

find_by_author(author) — вернуть список книг этого автора.​

borrow(title) — найти книгу по названию, если доступна — пометить is_available = False, иначе выдать сообщение, что книгу уже взяли.​

return_book(title) — вернуть книгу, снова сделать is_available = True.​

В основной части: создать несколько книг, добавить в библиотеку, «выдать» и «вернуть» одну из них, вывести список доступных.​

Задача 3. Фигуры: площадь и периметр (наследование + полиморфизм)
Сделайте иерархию геометрических фигур.​

Требования:

Базовый класс Shape с абстрактными методами area() и perimeter() (можно просто raise NotImplementedError).​

Класс Rectangle(Shape) с атрибутами width, height и реализацией area и perimeter.​

Класс Circle(Shape) с атрибутом radius и методами area, perimeter (длина окружности).​

Класс Square(Rectangle) у которого в конструкторе только один параметр side, внутри вызывает super().__init__(side, side).​

В основной части: создать список фигур разных типов и в цикле вывести их тип, площадь и периметр, вызывая одни и те же методы area() и perimeter() (полиморфизм).​

Задача 4. Банк: клиенты и счета (наследование + классовые атрибуты)
Смоделируйте систему банковских счетов.​

Требования:

Класс Account:

Атрибут класса interest_rate (например, 0.03 для 3% годовых).​

В __init__: owner, balance.​

Методы deposit(amount), withdraw(amount) (не давать уйти в минус), add_interest() — прибавляет проценты к балансу.​

Класс SavingsAccount(Account) — накопительный счёт, у которого своя ставка, например interest_rate = 0.05.​

Класс CheckingAccount(Account) — расчетный счёт, комиссия за каждое снятие, например 1 у.е., учитывается в withdraw.​

В основной части: создать по одному счёту каждого типа, сделать несколько операций, начислить проценты и вывести итоговые балансы.​

Задача 5. Меню ресторана и заказ (композиция + магические методы)
Нужно сделать простую модель заказа в ресторане.​

Требования:

Класс MenuItem: name, price.​

Класс Order: хранит список позиций и реализует:

add_item(item, quantity) — добавить позицию в заказ.​

total() — сумма заказа.​

Магический метод __str__, который возвращает красивый чек со строками вида "Блюдо — кол-во — сумма" и итогом внизу.​

Дополнительно: перегрузить __len__, чтобы len(order) возвращал количество разных позиций в заказе.​

В основной части: создать несколько позиций меню, собрать заказ из них и вывести его.​

Задача 6. Система задач (ToDo) с приоритетами (инкапсуляция + сортировка)
Сделайте простой менеджер задач.​

Требования:

Класс Task:

Приватные атрибуты __title, __priority (число, где 1 — высокий приоритет, 3 — низкий).​

Свойства (@property) для чтения и изменения приоритета с проверкой, что он в диапазоне 1–3.​

Магический __str__, возвращающий строку "Задача: <title>, приоритет: <priority>".​

Класс TaskManager:

Хранит список задач.​

Метод add_task(task).​

Метод get_tasks_by_priority(), который возвращает задачи, отсортированные по приоритету (1 сначала).​

Метод remove_task(title), который удаляет задачу по названию.​

В основной части: создать несколько задач с разными приоритетами, добавить в менеджер, вывести отсортированный список, удалить одну задачу и снова вывести.​